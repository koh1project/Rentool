/// <reference path="../../firebase.d.ts" />
import { Reservation } from './domain/Reservation.js';
import { Location } from './domain/Location.js';
import { PATHS_PAGES, movePageTo, SaveUserId } from './util.js';

const firebaseConfig = {
  apiKey: 'AIzaSyA7JwpO8rrYXgeKfiokAoymg2vJia3h7Nc',
  authDomain: 'rentool-4a9e6.firebaseapp.com',
  projectId: 'rentool-4a9e6',
  storageBucket: 'rentool-4a9e6.appspot.com',
  messagingSenderId: '357202195995',
  appId: '1:357202195995:web:4a7e7342acf44dd4f4eabe',
  measurementId: 'G-B5QXJNMD7M'
};

const app = firebase.initializeApp(firebaseConfig);
let db = firebase.default.firestore();

/**
 * @description Sign-in with Email and Password
 * @async
 * @param {string} email
 * @param {string} password
 * @returns {Promise}
 */
export const signInEmailWithPassword = async (email, password) => {
  let userId = null;
  db.collection('Users')
    .where('email', '==', email).where('pswd', '==', password).get().then((querySnapshot) => {
      querySnapshot.forEach((doc) => {
        console.log(doc.id, ' => ', doc.data());
        userId = doc.id;
      });
      if (querySnapshot.size === 0) {
        alert('SignIn failed');
        return;
      }

      userId && SaveUserId(userId);
      alert('SignIn Success');
      // window.history.back();
      movePageTo(PATHS_PAGES.HOME);
    })
    .catch((error) => {
      console.log('Error getting documents: ', error);
      alert(`ERROR: ${error}`);
    });
};

/**
 * @description Get tool information by Category
 * @async
 * @param {string} category
 * @return {object []}
 */
export const getToolsByCategory = async (category = '') => {
  const toolsDoc = await db.collection('Tools').where('category', '==', category).get();
  const tools = [];
  toolsDoc.forEach(doc => tools.push({ toolId: doc.id, ...doc.data(), }));

  return tools;
};

/**
 * @description Get tool information by Keyword
 * @async
 * @param {string} keyword
 * @return {object[]}
 */
export const getToolsByKeyword = async (keyword = '') => {
  let tools = [];
  try {
    const toolsDoc = await db.collection('Tools').get();
    toolsDoc.forEach(doc => { tools.push({ toolId: doc.id, ...doc.data() }); });

    // Return all data when the keyword is empty
    if (keyword === '') {
      return tools;
    }

    tools = tools.filter(tool => JSON.stringify(tool).includes(keyword));
    return tools;

  } catch (error) {
    console.error(error);
  }
};

/**
 * @description Get all tool information
 * @async
 * @return {Tool[]}
 */
export const getAllTools = async () => {
  let tools = [];
  try {
    const toolsDoc = await db.collection('Tools').get();
    toolsDoc.forEach(doc => { tools.push({ toolId: doc.id, ...doc.data() }); });
    return tools;

  } catch (error) {
    console.error(error);
  }
};


/**
 * @description Set tool data into Tools collection, mostly for testing purposes
 * @async
 * @param {Tool} tool
 */
export const setToolData = async (tool) => {
  try {
    // await db.collection('Tools').add({ ...tool });
    await setDataTo('Tools', tool);
  } catch (error) {
    console.error(error);
  }
};

/**
 * @description Set data to collection
 * @async
 * @param {string} collectionName
 * @param {object} params
 */
const setDataTo = async (collectionName, params) => {

  try {
    await db.collection(collectionName).add({ ...params });
  } catch (error) {
    console.error(error);
  }
};

/**
 * @description Get tool information by reservationToolIndex
 * @async
 * @param {string} reservationToolIndex
 * @return {Tool[]}
 */
export const getToolsByReservationToolIndex = async (reservationToolIndex) => {
  if (!reservationToolIndex) { return; }

  /**@type {Tool[]} */
  let tools = [];
  try {
    const toolsDoc = await db.collection('Tools').where('reservationToolIndex', '==', reservationToolIndex).get();
    toolsDoc.forEach(doc => { tools.push({ toolId: doc.id, ...doc.data() }); });
    return tools;
  } catch (error) {
    console.error(error);
  }
};



/**
 * @description Get reservation information by userId
 * @async
 * @param {string} userId
 * @return {Reservation[]}
 */
export const getReservationsByUserId = async (userId) => {
  if (!userId) { return; }

  try {
    const reservationsDoc = await db.collection('Reservations').where('userId', '==', userId).get();
    /**@type {Reservation[]} */
    let reservations = [];
    reservationsDoc.forEach(doc => { reservations.push({ reservationId: doc.id, ...doc.data() }); });
    return reservations;
  } catch (error) {
    console.error(error);
  }
};

/**
 * @description Update tool data by toolId
 * @async
 * @param {string} toolId // Autogenerated document id
 * @param {object} params
 */
export const updateToolByToolId = async (toolId, params) => {
  if (!params) { return; }

  try {
    await db.collection('Tools').doc(toolId).update(params);
  } catch (error) {
    console.error(error);
  }
};


/**
 * @description Set reservation data into Reservations collection
 * @async
 * @param {Reservation} reservation
 */
export const setReservationData = async (reservation) => {
  try {
    await setDataTo('Reservations', reservation);

  } catch (error) {
    console.error(error);
  }
};

/**
 * @description Update reservation data by reservationId
 * @async
 * @param {string} reservationId // Autogenerated document id
 * @param {object} params
 */
export const updateReservationByReservationId = async (reservationId, params) => {
  if (!params) { return; }

  try {
    await db.collection('Reservations').doc(reservationId).update(params);
  } catch (error) {
    console.error(error);
  }
};



/**
 * @description Return tools, change reservation data and tool data
 * @async
 * @param {Reservation} reservation
 * @param {Location} locationToReturn
 */
export const returnTool = async (reservation, locationToReturn) => {
  const { reservationId, toolId } = reservation;


  //@ TODO: Delete This Mock Request
  return setTimeout((async () => {
    console.log(`${reservationId}'s is returned, ToolId: ${toolId}'s isReserved will be false`);
    console.log(`ToolId: ${toolId} will be back to ${locationToReturn.address}`);

    alert(`ToolId: ${toolId} will be back to ${locationToReturn.address}`);

    await setTimeout(movePageTo(PATHS_PAGES.RETURN_COMPLETE), 5000);

  }), 500);


  try {
    // Change reservation data
    if (reservation.isReturned === false) {
      updateReservationByReservationId(reservationId, { isReturned: true });
    }

    // Change tool data
    updateToolByToolId(toolId, { isReserved: false, location: locationToReturn });

  } catch (error) {
    console.error(error);
  }
};